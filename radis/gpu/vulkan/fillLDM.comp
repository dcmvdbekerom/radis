#version 450
#extension GL_EXT_scalar_block_layout : enable
layout (local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2 ) in;
layout (constant_id = 3) const int HAS_ATOMIC_ADD_FLOAT = 0; //this value is updated by the host code

// if (HAS_ATOMIC_ADD_FLOAT):
// #extension GL_EXT_shader_atomic_float : enable
// #define FLOAT_TYPE float
// #define atomicAddFloatX(MEM, INDATA) atomicAdd(MEM, INDATA)
// else:
#define FLOAT_TYPE uint
#define atomicAddFloatX(MEM, INDATA)      \
{                                         \
    uint expected_mem = MEM;              \
    uint new_mem = floatBitsToUint(uintBitsToFloat(MEM) + INDATA); \
    uint returned_mem = atomicCompSwap(MEM, expected_mem, new_mem); \
    while(returned_mem != expected_mem){ \
        expected_mem = returned_mem; \
        new_mem = floatBitsToUint(uintBitsToFloat(expected_mem) + INDATA); \
        returned_mem = atomicCompSwap(MEM, expected_mem, new_mem); \
    } \
}

layout(std430, binding = 0) uniform initData{
    float v_min;
    float dv;
    int N_v;
    int N_v_FT;
	int N_x_FT;
    //float dxG;
    float dxL;
    int N_lines;
	//int N_coll;
    float log_c2Mm[16];
} init_d;

layout(std430, binding = 1) uniform iterData{
    //float p;
    float log_2p;
    //float hlog_T;
    float log_rT;
    float c2T;
    float N;
    //float x[16];
    //float l;
    //float slit_FWHM;
    //float log_wG_min;
    float log_wL_min;
    //int N_G;
    int N_L;
    //float Q[16];
} iter_d;


layout(std430, binding = 2) readonly buffer database_SSBO {
   float database_d[];
};

layout(std430, binding = 3) buffer SSBO1 {
  FLOAT_TYPE data_LDM_d[];
};

void main() {

	uint i = gl_WorkGroupID.x * gl_WorkGroupSize.x + gl_LocalInvocationID.x; //gl_GlobalInvocationID.x;

	if (i >= init_d.N_lines) return;

    float iso   = floatBitsToUint(database_d[i]);
    float v0    = database_d[i + 1*init_d.N_lines];
    float da    = database_d[i + 2*init_d.N_lines];
    float S0    = database_d[i + 3*init_d.N_lines];
    float El    = database_d[i + 4*init_d.N_lines];
    float na    = database_d[i + 5*init_d.N_lines];
    float gamma = database_d[i + 6*init_d.N_lines];

    float ki = (v0 - init_d.v_min) / init_d.dv;
    int k0i = int(ki);
    int k1i = k0i + 1;
    float avi = ki - float(k0i);

    if ((k0i < 0) || (k1i >= init_d.N_v)) return;

    // float log_wG_data = log(v0) + init_d.log_c2Mm[iso] + iter_d.hlog_T;
    // float li = (log_wG_data - iter_d.log_wG_min) / init_d.dxG;
    // int l0i = int(li);
    // int l1i = l0i + 1;
    // float aLi = li - float(l0i);

    float log_wL_data = log(gamma) + iter_d.log_2p + na * iter_d.log_rT;
    float mi = (log_wL_data - iter_d.log_wL_min) / init_d.dxL;
    int m0i = int(mi);
    int m1i = m0i + 1;
    float aLi = mi - float(m0i);

    float I_data = iter_d.N * S0 * (exp(-iter_d.c2T * El) - exp(-iter_d.c2T * (El + v0)));

    atomicAddFloatX(data_LDM_d[m0i * init_d.N_v_FT + k0i], (1 - aLi) * (1 - avi) * I_data);
    atomicAddFloatX(data_LDM_d[m0i * init_d.N_v_FT + k1i], (1 - aLi) * avi * I_data);
    atomicAddFloatX(data_LDM_d[m1i * init_d.N_v_FT + k0i], aLi * (1 - avi) * I_data);
    atomicAddFloatX(data_LDM_d[m1i * init_d.N_v_FT + k1i], aLi * avi * I_data);

}
