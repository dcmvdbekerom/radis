#version 450
#extension GL_EXT_scalar_block_layout : enable
layout (local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2 ) in;
layout (constant_id = 3) const int HAS_ATOMIC_ADD_FLOAT = 0; //this value is updated by the host code

// if (HAS_ATOMIC_ADD_FLOAT):
// #extension GL_EXT_shader_atomic_float : enable
// #define FLOAT_TYPE float
// #define atomicAddFloatX(MEM, INDATA) atomicAdd(MEM, INDATA)
// else:
#define FLOAT_TYPE uint
#define atomicAddFloatX(MEM, INDATA)      \
{                                         \
    uint expected_mem = MEM;              \
    uint new_mem = floatBitsToUint(uintBitsToFloat(MEM) + INDATA); \
    uint returned_mem = atomicCompSwap(MEM, expected_mem, new_mem); \
    while(returned_mem != expected_mem){ \
        expected_mem = returned_mem; \
        new_mem = floatBitsToUint(uintBitsToFloat(expected_mem) + INDATA); \
        returned_mem = atomicCompSwap(MEM, expected_mem, new_mem); \
    } \
}

layout(std430, binding = 0) uniform initData{
    int N_v;
    int N_v_FT;
	int N_x_FT;
    int N_lines;
	float dv;
    float v_min;
    float dxL;
} init_d;

layout(std430, binding = 1) uniform iterData{
    int N_L;
    float log_w_min;
    float T;
} iter_d;

layout(std430, binding = 2) readonly buffer database_SSBO {
   float database_d[];
};

layout(std430, binding = 3) buffer SSBO1 {
  FLOAT_TYPE data_LDM_d[];
};

void main() {

	uint i = gl_WorkGroupID.x * gl_WorkGroupSize.x + gl_LocalInvocationID.x; //gl_GlobalInvocationID.x;

	if (i >= init_d.N_lines) return;

    float v0_data    = database_d[i              ];
    float log_w_data = database_d[i + 1*init_d.N_lines];
    float E_data     = database_d[i + 2*init_d.N_lines];

    float ki = (v0_data - init_d.v_min) / init_d.dv;
    int k0i = int(ki);
    int k1i = k0i + 1;
    float avi = ki - float(k0i);

    float li = (log_w_data - iter_d.log_w_min) / init_d.dxL;
    int l0i = int(li);
    int l1i = l0i + 1;
    float aLi = li - float(l0i);

    float I_data = exp(-E_data/iter_d.T);

    atomicAddFloatX(data_LDM_d[l0i * init_d.N_v_FT + k0i], (1 - aLi) * (1 - avi) * I_data);
    atomicAddFloatX(data_LDM_d[l0i * init_d.N_v_FT + k1i], (1 - aLi) * avi * I_data);
    atomicAddFloatX(data_LDM_d[l1i * init_d.N_v_FT + k0i], aLi * (1 - avi) * I_data);
    atomicAddFloatX(data_LDM_d[l1i * init_d.N_v_FT + k1i], aLi * avi * I_data);

}
